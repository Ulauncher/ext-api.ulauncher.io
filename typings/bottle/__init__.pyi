"""
This type stub file was generated by pyright.
"""

import sys
import base64
import calendar
import email.utils
import functools
import hmac
import itertools
import mimetypes
import os
import re
import tempfile
import threading
import time
import warnings
import weakref
import hashlib
import http.client as httplib
import _thread as thread
import pickle
import configparser
import httplib
import thread
import cPickle as pickle
import ConfigParser as configparser
from types import FunctionType, ModuleType as new_module
from datetime import date as datedate, datetime, timedelta, timezone, tzinfo
from tempfile import NamedTemporaryFile
from traceback import format_exc, print_exc
from unicodedata import normalize
from ujson import dumps as json_dumps, loads as json_lds
from urllib.parse import SplitResult as UrlSplitResult, quote as urlquote, unquote as urlunquote, urlencode, urljoin
from http.cookies import CookieError, Morsel, SimpleCookie
from collections.abc import MutableMapping as DictMixin
from io import BytesIO
from inspect import getargspec, getfullargspec
from urlparse import SplitResult as UrlSplitResult, urljoin
from urllib import quote as urlquote, unquote as urlunquote, urlencode
from Cookie import CookieError, Morsel, SimpleCookie
from itertools import imap
from imp import new_module
from StringIO import StringIO as BytesIO
from collections import MutableMapping as DictMixin

__author__ = ...
__version__ = ...
__license__ = ...
if __name__ == '__main__':
    ...
py = ...
py3k = ...
if py3k:
    urlunquote = ...
    UTC = ...
    def getargspec(func): # -> tuple[list[str] | list[Never] | list[Any], str | None, str | None, tuple[Any, ...] | None]:
        ...
    
    basestring = str
    unicode = ...
    json_loads = ...
    callable = ...
    imap = ...
else:
    class _UTC(tzinfo):
        def utcoffset(self, dt): # -> timedelta:
            ...
        
        def tzname(self, dt): # -> Literal['UTC']:
            ...
        
        def dst(self, dt): # -> timedelta:
            ...
        
    
    
    UTC = ...
    unicode = ...
    json_loads = ...
def tob(s, enc=...): # -> bytes:
    ...

def touni(s, enc=..., err=...): # -> str:
    ...

tonat = ...
def update_wrapper(wrapper, wrapped, *a, **ka): # -> None:
    ...

def depr(major, minor, cause, fix, stacklevel=...): # -> DeprecationWarning:
    ...

def makelist(data): # -> list[Any]:
    ...

class DictProperty:
    """ Property that maps to a key in a local dict-like attribute. """
    def __init__(self, attr, key=..., read_only=...) -> None:
        ...
    
    def __call__(self, func): # -> Self:
        ...
    
    def __get__(self, obj, cls): # -> Self | Any:
        ...
    
    def __set__(self, obj, value): # -> None:
        ...
    
    def __delete__(self, obj): # -> None:
        ...
    


class cached_property:
    """ A property that is only computed once per instance and then replaces
        itself with an ordinary attribute. Deleting the attribute resets the
        property. """
    def __init__(self, func) -> None:
        ...
    
    def __get__(self, obj, cls): # -> Self:
        ...
    


class lazy_attribute:
    """ A property that caches itself to the class object. """
    def __init__(self, func) -> None:
        ...
    
    def __get__(self, obj, cls):
        ...
    


class BottleException(Exception):
    """ A base class for exceptions used by bottle. """
    ...


class RouteError(BottleException):
    """ This is a base class for all routing related exceptions """
    ...


class RouteReset(BottleException):
    """ If raised by a plugin or request handler, the route is reset and all
        plugins are re-applied. """
    ...


class RouterUnknownModeError(RouteError):
    ...


class RouteSyntaxError(RouteError):
    """ The route parser found something not supported by this router. """
    ...


class RouteBuildError(RouteError):
    """ The route could not be built. """
    ...


class Router:
    """ A Router is an ordered collection of route->target pairs. It is used to
        efficiently match WSGI requests against a number of routes and return
        the first target that satisfies the request. The target may be anything,
        usually a string, ID or callable object. A route consists of a path-rule
        and a HTTP method.

        The path-rule is either a static path (e.g. `/contact`) or a dynamic
        path that contains wildcards (e.g. `/wiki/<page>`). The wildcard syntax
        and details on the matching order are described in docs:`routing`.
    """
    default_pattern = ...
    default_filter = ...
    _MAX_GROUPS_PER_PATTERN = ...
    def __init__(self, strict=...) -> None:
        ...
    
    def add_filter(self, name, func): # -> None:
        """ Add a filter. The provided function is called with the configuration
        string as parameter and must return a (regexp, to_python, to_url) tuple.
        The first element is a string, the last two are callables or None. """
        ...
    
    rule_syntax = ...
    def add(self, rule, method, target, name=...): # -> None:
        """ Add a new rule or replace the target for an existing rule. """
        ...
    
    def build(self, _name, *anons, **query): # -> LiteralString | str:
        """ Build an URL by filling the wildcards in a rule. """
        ...
    
    def match(self, environ): # -> tuple[Any, Any | dict[Any, Any]]:
        """ Return a (target, url_args) tuple or raise HTTPError(400/404/405). """
        ...
    


class Route:
    """ This class wraps a route callback along with route specific metadata and
        configuration and applies Plugins on demand. It is also responsible for
        turning an URL path rule into a regular expression usable by the Router.
    """
    def __init__(self, app, rule, method, callback, name=..., plugins=..., skiplist=..., **config) -> None:
        ...
    
    @cached_property
    def call(self): # -> Any:
        """ The route callback with all plugins applied. This property is
            created on demand and then cached to speed up subsequent requests."""
        ...
    
    def reset(self): # -> None:
        """ Forget any cached values. The next time :attr:`call` is accessed,
            all plugins are re-applied. """
        ...
    
    def prepare(self): # -> None:
        """ Do all on-demand work immediately (useful for debugging)."""
        ...
    
    def all_plugins(self): # -> Generator[Any, Any, None]:
        """ Yield all Plugins affecting this route. """
        ...
    
    def get_undecorated_callback(self): # -> Any:
        """ Return the callback. If the callback is a decorated function, try to
            recover the original function. """
        ...
    
    def get_callback_args(self): # -> list[str] | list[Never] | list[Any]:
        """ Return a list of argument names the callback (most likely) accepts
            as keyword arguments. If the callback is a decorated function, try
            to recover the original function before inspection. """
        ...
    
    def get_config(self, key, default=...):
        """ Lookup a config field and return its value, first checking the
            route.config, then route.app.config."""
        ...
    
    def __repr__(self): # -> str:
        ...
    


class Bottle:
    """ Each Bottle object represents a single, distinct web application and
        consists of routes, callbacks, plugins, resources and configuration.
        Instances are callable WSGI applications.

        :param catchall: If true (default), handle all exceptions. Turn off to
                         let debugging middleware handle exceptions.
    """
    def __init__(self, **kwargs) -> None:
        ...
    
    catchall = ...
    __hook_names = ...
    __hook_reversed = ...
    def add_hook(self, name, func): # -> None:
        """ Attach a callback to a hook. Three hooks are currently implemented:

            before_request
                Executed once before each request. The request context is
                available, but no routing has happened yet.
            after_request
                Executed once after each request regardless of its outcome.
            app_reset
                Called whenever :meth:`Bottle.reset` is called.
        """
        ...
    
    def remove_hook(self, name, func): # -> Literal[True] | None:
        """ Remove a callback from a hook. """
        ...
    
    def trigger_hook(self, __name, *args, **kwargs): # -> list[Any]:
        """ Trigger a hook and return a list of results. """
        ...
    
    def hook(self, name): # -> Callable[..., Any]:
        """ Return a decorator that attaches a callback to a hook. See
            :meth:`add_hook` for details."""
        ...
    
    def mount(self, prefix, app, **options): # -> None:
        """ Mount an application (:class:`Bottle` or plain WSGI) to a specific
            URL prefix. Example::

                parent_app.mount('/prefix/', child_app)

            :param prefix: path prefix or `mount-point`.
            :param app: an instance of :class:`Bottle` or a WSGI application.

            Plugins from the parent application are not applied to the routes
            of the mounted child application. If you need plugins in the child
            application, install them separately.

            While it is possible to use path wildcards within the prefix path
            (:class:`Bottle` childs only), it is highly discouraged.

            The prefix path must end with a slash. If you want to access the
            root of the child application via `/prefix` in addition to
            `/prefix/`, consider adding a route with a 307 redirect to the
            parent application.
        """
        ...
    
    def merge(self, routes): # -> None:
        """ Merge the routes of another :class:`Bottle` application or a list of
            :class:`Route` objects into this application. The routes keep their
            'owner', meaning that the :data:`Route.app` attribute is not
            changed. """
        ...
    
    def install(self, plugin):
        """ Add a plugin to the list of plugins and prepare it for being
            applied to all routes of this application. A plugin may be a simple
            decorator or an object that implements the :class:`Plugin` API.
        """
        ...
    
    def uninstall(self, plugin): # -> list[Any]:
        """ Uninstall plugins. Pass an instance to remove a specific plugin, a type
            object to remove all plugins that match that type, a string to remove
            all plugins with a matching ``name`` attribute or ``True`` to remove all
            plugins. Return the list of removed plugins. """
        ...
    
    def reset(self, route=...): # -> None:
        """ Reset all routes (force plugins to be re-applied) and clear all
            caches. If an ID or route object is given, only that specific route
            is affected. """
        ...
    
    def close(self): # -> None:
        """ Close the application and all installed plugins. """
        ...
    
    def run(self, **kwargs): # -> None:
        """ Calls :func:`run` with the same parameters. """
        ...
    
    def match(self, environ): # -> tuple[Any, Any | dict[Any, Any]]:
        """ Search for a matching route and return a (:class:`Route`, urlargs)
            tuple. The second value is a dictionary with parameters extracted
            from the URL. Raise :exc:`HTTPError` (404/405) on a non-match."""
        ...
    
    def get_url(self, routename, **kargs): # -> str:
        """ Return a string that matches a named route """
        ...
    
    def add_route(self, route): # -> None:
        """ Add a route object, but do not change the :data:`Route.app`
            attribute."""
        ...
    
    def route(self, path=..., method=..., callback=..., name=..., apply=..., skip=..., **config): # -> ModuleType | Any | Callable[..., ModuleType | Any]:
        """ A decorator to bind a function to a request URL. Example::

                @app.route('/hello/<name>')
                def hello(name):
                    return 'Hello %s' % name

            The ``<name>`` part is a wildcard. See :class:`Router` for syntax
            details.

            :param path: Request path or a list of paths to listen to. If no
              path is specified, it is automatically generated from the
              signature of the function.
            :param method: HTTP method (`GET`, `POST`, `PUT`, ...) or a list of
              methods to listen to. (default: `GET`)
            :param callback: An optional shortcut to avoid the decorator
              syntax. ``route(..., callback=func)`` equals ``route(...)(func)``
            :param name: The name for this route. (default: None)
            :param apply: A decorator or plugin or a list of plugins. These are
              applied to the route callback in addition to installed plugins.
            :param skip: A list of plugins, plugin classes or names. Matching
              plugins are not installed to this route. ``True`` skips all.

            Any additional keyword arguments are stored as route-specific
            configuration and passed to plugins (see :meth:`Plugin.apply`).
        """
        ...
    
    def get(self, path=..., method=..., **options): # -> ModuleType | Any | Callable[..., ModuleType | Any]:
        """ Equals :meth:`route`. """
        ...
    
    def post(self, path=..., method=..., **options): # -> ModuleType | Any | Callable[..., ModuleType | Any]:
        """ Equals :meth:`route` with a ``POST`` method parameter. """
        ...
    
    def put(self, path=..., method=..., **options): # -> ModuleType | Any | Callable[..., ModuleType | Any]:
        """ Equals :meth:`route` with a ``PUT`` method parameter. """
        ...
    
    def delete(self, path=..., method=..., **options): # -> ModuleType | Any | Callable[..., ModuleType | Any]:
        """ Equals :meth:`route` with a ``DELETE`` method parameter. """
        ...
    
    def patch(self, path=..., method=..., **options): # -> ModuleType | Any | Callable[..., ModuleType | Any]:
        """ Equals :meth:`route` with a ``PATCH`` method parameter. """
        ...
    
    def error(self, code=..., callback=...): # -> ModuleType | Any | Callable[..., ModuleType | Any]:
        """ Register an output handler for a HTTP error code. Can
            be used as a decorator or called directly ::

                def error_handler_500(error):
                    return 'error_handler_500'

                app.error(code=500, callback=error_handler_500)

                @app.error(404)
                def error_handler_404(error):
                    return 'error_handler_404'

        """
        ...
    
    def default_error_handler(self, res): # -> bytes:
        ...
    
    def wsgi(self, environ, start_response):
        """ The bottle WSGI-interface. """
        ...
    
    def __call__(self, environ, start_response):
        """ Each instance of :class:'Bottle' is a WSGI application. """
        ...
    
    def __enter__(self): # -> Self:
        """ Use this application as default for all module-level shortcuts. """
        ...
    
    def __exit__(self, exc_type, exc_value, traceback): # -> None:
        ...
    
    def __setattr__(self, name, value): # -> None:
        ...
    


class BaseRequest:
    """ A wrapper for WSGI environment dictionaries that adds a lot of
        convenient access methods and properties. Most of them are read-only.

        Adding new attributes to a request actually adds them to the environ
        dictionary (as 'bottle.request.ext.<name>'). This is the recommended
        way to store and access request-specific data.
    """
    __slots__ = ...
    MEMFILE_MAX = ...
    def __init__(self, environ=...) -> None:
        """ Wrap a WSGI environ dictionary. """
        ...
    
    @DictProperty('environ', 'bottle.app', read_only=True)
    def app(self):
        """ Bottle application handling this request. """
        ...
    
    @DictProperty('environ', 'bottle.route', read_only=True)
    def route(self):
        """ The bottle :class:`Route` object that matches this request. """
        ...
    
    @DictProperty('environ', 'route.url_args', read_only=True)
    def url_args(self):
        """ The arguments extracted from the URL. """
        ...
    
    @property
    def path(self):
        """ The value of ``PATH_INFO`` with exactly one prefixed slash (to fix
            broken clients and avoid the "empty path" edge case). """
        ...
    
    @property
    def method(self):
        """ The ``REQUEST_METHOD`` value as an uppercase string. """
        ...
    
    @DictProperty('environ', 'bottle.request.headers', read_only=True)
    def headers(self): # -> WSGIHeaderDict:
        """ A :class:`WSGIHeaderDict` that provides case-insensitive access to
            HTTP request headers. """
        ...
    
    def get_header(self, name, default=...): # -> Any:
        """ Return the value of a request header, or a given default value. """
        ...
    
    @DictProperty('environ', 'bottle.request.cookies', read_only=True)
    def cookies(self): # -> FormsDict:
        """ Cookies parsed into a :class:`FormsDict`. Signed cookies are NOT
            decoded. Use :meth:`get_cookie` if you expect signed cookies. """
        ...
    
    def get_cookie(self, key, default=..., secret=..., digestmod=...): # -> Any | None:
        """ Return the content of a cookie. To read a `Signed Cookie`, the
            `secret` must match the one used to create the cookie (see
            :meth:`BaseResponse.set_cookie`). If anything goes wrong (missing
            cookie or wrong signature), return a default value. """
        ...
    
    @DictProperty('environ', 'bottle.request.query', read_only=True)
    def query(self): # -> FormsDict:
        """ The :attr:`query_string` parsed into a :class:`FormsDict`. These
            values are sometimes called "URL arguments" or "GET parameters", but
            not to be confused with "URL wildcards" as they are provided by the
            :class:`Router`. """
        ...
    
    @DictProperty('environ', 'bottle.request.forms', read_only=True)
    def forms(self): # -> FormsDict:
        """ Form values parsed from an `url-encoded` or `multipart/form-data`
            encoded POST or PUT request body. The result is returned as a
            :class:`FormsDict`. All keys and values are strings. File uploads
            are stored separately in :attr:`files`. """
        ...
    
    @DictProperty('environ', 'bottle.request.params', read_only=True)
    def params(self): # -> FormsDict:
        """ A :class:`FormsDict` with the combined values of :attr:`query` and
            :attr:`forms`. File uploads are stored in :attr:`files`. """
        ...
    
    @DictProperty('environ', 'bottle.request.files', read_only=True)
    def files(self): # -> FormsDict:
        """ File uploads parsed from `multipart/form-data` encoded POST or PUT
            request body. The values are instances of :class:`FileUpload`.

        """
        ...
    
    @DictProperty('environ', 'bottle.request.json', read_only=True)
    def json(self): # -> Any | None:
        """ If the ``Content-Type`` header is ``application/json`` or
            ``application/json-rpc``, this property holds the parsed content
            of the request body. Only requests smaller than :attr:`MEMFILE_MAX`
            are processed to avoid memory exhaustion.
            Invalid JSON raises a 400 error response.
        """
        ...
    
    @property
    def body(self): # -> DictProperty | Any:
        """ The HTTP request body as a seek-able file-like object. Depending on
            :attr:`MEMFILE_MAX`, this is either a temporary file or a
            :class:`io.BytesIO` instance. Accessing this property for the first
            time reads and replaces the ``wsgi.input`` environ variable.
            Subsequent accesses just do a `seek(0)` on the file object. """
        ...
    
    @property
    def chunked(self): # -> bool:
        """ True if Chunked transfer encoding was. """
        ...
    
    GET = ...
    @DictProperty('environ', 'bottle.request.post', read_only=True)
    def POST(self): # -> FormsDict:
        """ The values of :attr:`forms` and :attr:`files` combined into a single
            :class:`FormsDict`. Values are either strings (form values) or
            instances of :class:`FileUpload`.
        """
        ...
    
    @property
    def url(self): # -> Any:
        """ The full request URI including hostname and scheme. If your app
            lives behind a reverse proxy or load balancer and you get confusing
            results, make sure that the ``X-Forwarded-Host`` header is set
            correctly. """
        ...
    
    @DictProperty('environ', 'bottle.request.urlparts', read_only=True)
    def urlparts(self): # -> SplitResult:
        """ The :attr:`url` string as an :class:`urlparse.SplitResult` tuple.
            The tuple contains (scheme, host, path, query_string and fragment),
            but the fragment is always empty because it is not visible to the
            server. """
        ...
    
    @property
    def fullpath(self): # -> str:
        """ Request path including :attr:`script_name` (if present). """
        ...
    
    @property
    def query_string(self):
        """ The raw :attr:`query` part of the URL (everything in between ``?``
            and ``#``) as a string. """
        ...
    
    @property
    def script_name(self): # -> Literal['/']:
        """ The initial portion of the URL's `path` that was removed by a higher
            level (server or routing middleware) before the application was
            called. This script path is returned with leading and tailing
            slashes. """
        ...
    
    def path_shift(self, shift=...): # -> None:
        """ Shift path segments from :attr:`path` to :attr:`script_name` and
            vice versa.

           :param shift: The number of path segments to shift. May be negative
                         to change the shift direction. (default: 1)
        """
        ...
    
    @property
    def content_length(self): # -> int:
        """ The request body length as an integer. The client is responsible to
            set this header. Otherwise, the real length of the body is unknown
            and -1 is returned. In this case, :attr:`body` will be empty. """
        ...
    
    @property
    def content_type(self):
        """ The Content-Type header as a lowercase-string (default: empty). """
        ...
    
    @property
    def is_xhr(self):
        """ True if the request was triggered by a XMLHttpRequest. This only
            works with JavaScript libraries that support the `X-Requested-With`
            header (most of the popular libraries do). """
        ...
    
    @property
    def is_ajax(self):
        """ Alias for :attr:`is_xhr`. "Ajax" is not the right term. """
        ...
    
    @property
    def auth(self): # -> tuple[str | Any, str | Any] | tuple[Any, None] | None:
        """ HTTP authentication data as a (user, password) tuple. This
            implementation currently supports basic (not digest) authentication
            only. If the authentication happened at a higher level (e.g. in the
            front web-server or a middleware), the password field is None, but
            the user field is looked up from the ``REMOTE_USER`` environ
            variable. On any errors, None is returned. """
        ...
    
    @property
    def remote_route(self): # -> list[Any]:
        """ A list of all IPs that were involved in this request, starting with
            the client IP and followed by zero or more proxies. This does only
            work if all proxies support the ```X-Forwarded-For`` header. Note
            that this information can be forged by malicious clients. """
        ...
    
    @property
    def remote_addr(self): # -> None:
        """ The client IP as a string. Note that this information can be forged
            by malicious clients. """
        ...
    
    def copy(self): # -> Request:
        """ Return a new :class:`Request` with a shallow :attr:`environ` copy. """
        ...
    
    def get(self, value, default=...): # -> None:
        ...
    
    def __getitem__(self, key):
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def __iter__(self): # -> Iterator[Any]:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def keys(self): # -> dict_keys[Any, Any]:
        ...
    
    def __setitem__(self, key, value): # -> None:
        """ Change an environ value and clear all caches that depend on it. """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __getattr__(self, name):
        """ Search in self.environ for additional user defined attributes. """
        ...
    
    def __setattr__(self, name, value): # -> None:
        """ Define new attributes that are local to the bound request environment. """
        ...
    
    def __delattr__(self, name): # -> None:
        ...
    


class HeaderProperty:
    def __init__(self, name, reader=..., writer=..., default=...) -> None:
        ...
    
    def __get__(self, obj, _): # -> Self:
        ...
    
    def __set__(self, obj, value): # -> None:
        ...
    
    def __delete__(self, obj): # -> None:
        ...
    


class BaseResponse:
    """ Storage class for a response body as well as headers and cookies.

        This class does support dict-like case-insensitive item-access to
        headers, but is NOT a dict. Most notably, iterating over a response
        yields parts of the body and not the headers.
    """
    default_status = ...
    default_content_type = ...
    bad_headers = ...
    def __init__(self, body=..., status=..., headers=..., **more_headers) -> None:
        """ Create a new response object.

        :param body: The response body as one of the supported types.
        :param status: Either an HTTP status code (e.g. 200) or a status line
                       including the reason phrase (e.g. '200 OK').
        :param headers: A dictionary or a list of name-value pairs.

        Additional keyword arguments are added to the list of headers.
        Underscores in the header name are replaced with dashes.
        """
        ...
    
    def copy(self, cls=...): # -> BaseResponse:
        """ Returns a copy of self. """
        ...
    
    def __iter__(self): # -> Iterator[str]:
        ...
    
    def close(self): # -> None:
        ...
    
    @property
    def status_line(self): # -> str:
        """ The HTTP status line as a string (e.g. ``404 Not Found``)."""
        ...
    
    @property
    def status_code(self): # -> int:
        """ The HTTP status code as an integer (e.g. 404)."""
        ...
    
    status = ...
    @property
    def headers(self): # -> HeaderDict:
        """ An instance of :class:`HeaderDict`, a case-insensitive dict-like
            view on the response headers. """
        ...
    
    def __contains__(self, name): # -> bool:
        ...
    
    def __delitem__(self, name): # -> None:
        ...
    
    def __getitem__(self, name):
        ...
    
    def __setitem__(self, name, value): # -> None:
        ...
    
    def get_header(self, name, default=...):
        """ Return the value of a previously defined header. If there is no
            header with that name, return a default value. """
        ...
    
    def set_header(self, name, value): # -> None:
        """ Create a new response header, replacing any previously defined
            headers with the same name. """
        ...
    
    def add_header(self, name, value): # -> None:
        """ Add an additional response header, not removing duplicates. """
        ...
    
    def iter_headers(self): # -> list[tuple[Any, Any]]:
        """ Yield (header, value) tuples, skipping headers that are not
            allowed with the current response status code. """
        ...
    
    @property
    def headerlist(self): # -> list[tuple[Any, Any]]:
        """ WSGI conform list of (header, value) tuples. """
        ...
    
    content_type = ...
    content_length = ...
    expires = ...
    @property
    def charset(self, default=...): # -> str:
        """ Return the charset specified in the content-type header (default: utf8). """
        ...
    
    def set_cookie(self, name, value, secret=..., digestmod=..., **options): # -> None:
        """ Create a new cookie or replace an old one. If the `secret` parameter is
            set, create a `Signed Cookie` (described below).

            :param name: the name of the cookie.
            :param value: the value of the cookie.
            :param secret: a signature key required for signed cookies.

            Additionally, this method accepts all RFC 2109 attributes that are
            supported by :class:`cookie.Morsel`, including:

            :param maxage: maximum age in seconds. (default: None)
            :param expires: a datetime object or UNIX timestamp. (default: None)
            :param domain: the domain that is allowed to read the cookie.
              (default: current domain)
            :param path: limits the cookie to a given path (default: current path)
            :param secure: limit the cookie to HTTPS connections (default: off).
            :param httponly: prevents client-side javascript to read this cookie
              (default: off, requires Python 2.6 or newer).
            :param samesite: Control or disable third-party use for this cookie.
              Possible values: `lax`, `strict` or `none` (default).

            If neither `expires` nor `maxage` is set (default), the cookie will
            expire at the end of the browser session (as soon as the browser
            window is closed).

            Signed cookies may store any pickle-able object and are
            cryptographically signed to prevent manipulation. Keep in mind that
            cookies are limited to 4kb in most browsers.

            Warning: Pickle is a potentially dangerous format. If an attacker
            gains access to the secret key, he could forge cookies that execute
            code on server side if unpickled. Using pickle is discouraged and
            support for it will be removed in later versions of bottle.

            Warning: Signed cookies are not encrypted (the client can still see
            the content) and not copy-protected (the client can restore an old
            cookie). The main intention is to make pickling and unpickling
            save, not to store secret information at client side.
        """
        ...
    
    def delete_cookie(self, key, **kwargs): # -> None:
        """ Delete a cookie. Be sure to use the same `domain` and `path`
            settings as used to create the cookie. """
        ...
    
    def __repr__(self): # -> LiteralString | Literal['']:
        ...
    


class LocalRequest(BaseRequest):
    """ A thread-local subclass of :class:`BaseRequest` with a different
        set of attributes for each thread. There is usually only one global
        instance of this class (:data:`request`). If accessed during a
        request/response cycle, this instance always refers to the *current*
        request (even on a multithreaded server). """
    bind = ...
    environ = ...


class LocalResponse(BaseResponse):
    """ A thread-local subclass of :class:`BaseResponse` with a different
        set of attributes for each thread. There is usually only one global
        instance of this class (:data:`response`). Its attributes are used
        to build the HTTP response at the end of the request/response cycle.
    """
    bind = ...
    _status_line = ...
    _status_code = ...
    _cookies = ...
    _headers = ...
    body = ...


Request = BaseRequest
Response = BaseResponse
class HTTPResponse(Response, BottleException):
    """ A subclass of :class:`Response` that can be raised or returned from request
        handlers to short-curcuit request processing and override changes made to the
        global :data:`request` object. This bypasses error handlers, even if the status
        code indicates an error. Return or raise :class:`HTTPError` to trigger error
        handlers.
    """
    def __init__(self, body=..., status=..., headers=..., **more_headers) -> None:
        ...
    
    def apply(self, other): # -> None:
        """ Copy the state of this response to a different :class:`Response` object. """
        ...
    


class HTTPError(HTTPResponse):
    """ A subclass of :class:`HTTPResponse` that triggers error handlers. """
    default_status = ...
    def __init__(self, status=..., body=..., exception=..., traceback=..., **more_headers) -> None:
        ...
    


class PluginError(BottleException):
    ...


class JSONPlugin:
    name = ...
    api = ...
    def __init__(self, json_dumps=...) -> None:
        ...
    
    def setup(self, app): # -> None:
        ...
    
    def apply(self, callback, route): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], str | HTTPResponse | Any]:
        ...
    


class TemplatePlugin:
    """ This plugin applies the :func:`view` decorator to all routes with a
        `template` config parameter. If the parameter is a tuple, the second
        element must be a dict with additional options (e.g. `template_engine`)
        or default variables for the template. """
    name = ...
    api = ...
    def setup(self, app): # -> None:
        ...
    
    def apply(self, callback, route): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
        ...
    


class _ImportRedirect:
    def __init__(self, name, impmask) -> None:
        """ Create a virtual package that redirects imports (see PEP 302). """
        ...
    
    def find_spec(self, fullname, path, target=...): # -> ModuleSpec | None:
        ...
    
    def find_module(self, fullname, path=...): # -> Self | None:
        ...
    
    def create_module(self, spec): # -> ModuleType:
        ...
    
    def exec_module(self, module): # -> None:
        ...
    
    def load_module(self, fullname): # -> ModuleType:
        ...
    


class MultiDict(DictMixin):
    """ This dict stores multiple values per key, but behaves exactly like a
        normal dict in that it returns only the newest value for any given key.
        There are special methods available to access the full list of values.
    """
    def __init__(self, *a, **k) -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __iter__(self): # -> Iterator[str]:
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def __getitem__(self, key):
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    def keys(self): # -> dict_keys[str, list[Any]]:
        ...
    
    if py3k:
        def values(self): # -> Generator[Any, None, None]:
            ...
        
        def items(self): # -> Generator[tuple[str, Any], None, None]:
            ...
        
        def allitems(self): # -> Generator[tuple[str, Any], None, None]:
            ...
        
        iterkeys = ...
        itervalues = ...
        iteritems = ...
        iterallitems = ...
    else:
        def values(self): # -> list[Any]:
            ...
        
        def items(self): # -> list[tuple[str, Any]]:
            ...
        
        def iterkeys(self):
            ...
        
        def itervalues(self): # -> Generator[Any, None, None]:
            ...
        
        def iteritems(self): # -> Generator[tuple[Any, Any], None, None]:
            ...
        
        def iterallitems(self): # -> Generator[tuple[Any, Any], None, None]:
            ...
        
        def allitems(self): # -> list[tuple[Any, Any]]:
            ...
        
    def get(self, key, default=..., index=..., type=...): # -> None:
        """ Return the most recent value for a key.

            :param default: The default value to be returned if the key is not
                   present or the type conversion fails.
            :param index: An index for the list of available values.
            :param type: If defined, this callable is used to cast the value
                    into a specific type. Exception are suppressed and result in
                    the default value to be returned.
        """
        ...
    
    def append(self, key, value): # -> None:
        """ Add a new value to the list of values for this key. """
        ...
    
    def replace(self, key, value): # -> None:
        """ Replace the list of values with a single value. """
        ...
    
    def getall(self, key): # -> list[Any]:
        """ Return a (possibly empty) list of values for a key. """
        ...
    
    getone = ...
    getlist = ...


class FormsDict(MultiDict):
    """ This :class:`MultiDict` subclass is used to store request form data.
        Additionally to the normal dict-like item access methods (which return
        unmodified data as native strings), this container also supports
        attribute-like access to its values. Attributes are automatically de-
        or recoded to match :attr:`input_encoding` (default: 'utf8'). Missing
        attributes default to an empty string. """
    input_encoding = ...
    recode_unicode = ...
    def decode(self, encoding=...): # -> FormsDict:
        """ Returns a copy with all keys and values de- or recoded to match
            :attr:`input_encoding`. Some libraries (e.g. WTForms) want a
            unicode dictionary. """
        ...
    
    def getunicode(self, name, default=..., encoding=...): # -> str | None:
        """ Return the value as a unicode string, or the default. """
        ...
    
    def __getattr__(self, name, default=...): # -> str | None:
        ...
    


class HeaderDict(MultiDict):
    """ A case-insensitive version of :class:`MultiDict` that defaults to
        replace the old value instead of appending it. """
    def __init__(self, *a, **ka) -> None:
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def __getitem__(self, key):
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    def append(self, key, value): # -> None:
        ...
    
    def replace(self, key, value): # -> None:
        ...
    
    def getall(self, key): # -> list[Any]:
        ...
    
    def get(self, key, default=..., index=...): # -> None:
        ...
    
    def filter(self, names): # -> None:
        ...
    


class WSGIHeaderDict(DictMixin):
    """ This dict-like class wraps a WSGI environ dict and provides convenient
        access to HTTP_* fields. Keys and values are native strings
        (2.x bytes or 3.x unicode) and keys are case-insensitive. If the WSGI
        environment contains non-native string values, these are de- or encoded
        using a lossless 'latin1' character set.

        The API will remain stable even on changes to the relevant PEPs.
        Currently PEP 333, 444 and 3333 are supported. (PEP 444 is the only one
        that uses non-native strings.)
    """
    cgikeys = ...
    def __init__(self, environ) -> None:
        ...
    
    def raw(self, key, default=...):
        """ Return the header value as is (may be bytes or unicode). """
        ...
    
    def __getitem__(self, key):
        ...
    
    def __setitem__(self, key, value):
        ...
    
    def __delitem__(self, key):
        ...
    
    def __iter__(self): # -> Generator[Any | str, Any, None]:
        ...
    
    def keys(self): # -> list[Any | str]:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    


_UNSET = ...
class ConfigDict(dict):
    """ A dict-like configuration storage with additional support for
        namespaces, validators, meta-data and overlays.

        This dict-like class is heavily optimized for read access.
        Read-only methods and item access should be as fast as a native dict.
    """
    __slots__ = ...
    def __init__(self) -> None:
        ...
    
    def load_module(self, name, squash=...): # -> Self:
        """Load values from a Python module.

           Import a python module by name and add all upper-case module-level
           variables to this config dict.

           :param name: Module name to import and load.
           :param squash: If true (default), nested dicts are assumed to
              represent namespaces and flattened (see :meth:`load_dict`).
        """
        ...
    
    def load_config(self, filename, **options): # -> Self:
        """ Load values from ``*.ini`` style config files using configparser.

            INI style sections (e.g. ``[section]``) are used as namespace for
            all keys within that section. Both section and key names may contain
            dots as namespace separators and are converted to lower-case.

            The special sections ``[bottle]`` and ``[ROOT]`` refer to the root
            namespace and the ``[DEFAULT]`` section defines default values for all
            other sections.

            :param filename: The path of a config file, or a list of paths.
            :param options: All keyword parameters are passed to the underlying
                :class:`python:configparser.ConfigParser` constructor call.

        """
        ...
    
    def load_dict(self, source, namespace=...): # -> Self:
        """ Load values from a dictionary structure. Nesting can be used to
            represent namespaces.

            >>> c = ConfigDict()
            >>> c.load_dict({'some': {'namespace': {'key': 'value'} } })
            {'some.namespace.key': 'value'}
        """
        ...
    
    def update(self, *a, **ka): # -> None:
        """ If the first parameter is a string, all keys are prefixed with this
            namespace. Apart from that it works just as the usual dict.update().

            >>> c = ConfigDict()
            >>> c.update('some.namespace', key='value')
        """
        ...
    
    def setdefault(self, key, value=...):
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def meta_get(self, key, metafield, default=...):
        """ Return the value of a meta field for a key. """
        ...
    
    def meta_set(self, key, metafield, value): # -> None:
        """ Set the meta field for a key to a new value.
        
            Meta-fields are shared between all members of an overlay tree.
        """
        ...
    
    def meta_list(self, key):
        """ Return an iterable of meta field names defined for a key. """
        ...
    


class AppStack(list):
    """ A stack-like list. Calling it returns the head of the stack. """
    def __call__(self): # -> Bottle:
        """ Return the current default application. """
        ...
    
    def push(self, value=...): # -> Bottle:
        """ Add a new :class:`Bottle` instance to the stack """
        ...
    
    new_app = ...
    @property
    def default(self): # -> Bottle:
        ...
    


class WSGIFileWrapper:
    def __init__(self, fp, buffer_size=...) -> None:
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        ...
    


class _closeiter:
    """ This only exists to be able to attach a .close method to iterators that
        do not support attribute assignment (most of itertools). """
    def __init__(self, iterator, close=...) -> None:
        ...
    
    def __iter__(self):
        ...
    
    def close(self): # -> None:
        ...
    


class ResourceManager:
    """ This class manages a list of search paths and helps to find and open
        application-bound resources (files).

        :param base: default value for :meth:`add_path` calls.
        :param opener: callable used to open resources.
        :param cachemode: controls which lookups are cached. One of 'all',
                         'found' or 'none'.
    """
    def __init__(self, base=..., opener=..., cachemode=...) -> None:
        ...
    
    def add_path(self, path, base=..., index=..., create=...): # -> bool:
        """ Add a new path to the list of search paths. Return False if the
            path does not exist.

            :param path: The new search path. Relative paths are turned into
                an absolute and normalized form. If the path looks like a file
                (not ending in `/`), the filename is stripped off.
            :param base: Path used to absolutize relative search paths.
                Defaults to :attr:`base` which defaults to ``os.getcwd()``.
            :param index: Position within the list of search paths. Defaults
                to last index (appends to the list).

            The `base` parameter makes it easy to reference files installed
            along with a python module or package::

                res.add_path('./resources/', __file__)
        """
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        """ Iterate over all existing files in all registered paths. """
        ...
    
    def lookup(self, name):
        """ Search for a resource and return an absolute file path, or `None`.

            The :attr:`path` list is searched in order. The first match is
            returned. Symlinks are followed. The result is cached to speed up
            future lookups. """
        ...
    
    def open(self, name, mode=..., *args, **kwargs):
        """ Find a resource and return a file object, or raise IOError. """
        ...
    


class FileUpload:
    def __init__(self, fileobj, name, filename, headers=...) -> None:
        """ Wrapper for a single file uploaded via ``multipart/form-data``. """
        ...
    
    content_type = ...
    content_length = ...
    def get_header(self, name, default=...): # -> None:
        """ Return the value of a header within the multipart part. """
        ...
    
    @cached_property
    def filename(self): # -> str:
        """ Name of the file on the client file system, but normalized to ensure
            file system compatibility. An empty filename is returned as 'empty'.

            Only ASCII letters, digits, dashes, underscores and dots are
            allowed in the final filename. Accents are removed, if possible.
            Whitespace is replaced by a single dash. Leading or tailing dots
            or dashes are removed. The filename is limited to 255 characters.
        """
        ...
    
    def save(self, destination, overwrite=..., chunk_size=...): # -> None:
        """ Save file to disk or copy its content to an open file(-like) object.
            If *destination* is a directory, :attr:`filename` is added to the
            path. Existing files are not overwritten by default (IOError).

            :param destination: File path, directory or file(-like) object.
            :param overwrite: If True, replace existing files. (default: False)
            :param chunk_size: Bytes to read at a time. (default: 64kb)
        """
        ...
    


def abort(code=..., text=...):
    """ Aborts execution and causes a HTTP error. """
    ...

def redirect(url, code=...):
    """ Aborts execution and causes a 303 or 302 redirect, depending on
        the HTTP protocol version. """
    ...

def static_file(filename, root, mimetype=..., download=..., charset=..., etag=..., headers=...):
    """ Open a file in a safe way and return an instance of :exc:`HTTPResponse`
        that can be sent back to the client.

        :param filename: Name or path of the file to send, relative to ``root``.
        :param root: Root path for file lookups. Should be an absolute directory
            path.
        :param mimetype: Provide the content-type header (default: guess from
            file extension)
        :param download: If True, ask the browser to open a `Save as...` dialog
            instead of opening the file with the associated program. You can
            specify a custom filename as a string. If not specified, the
            original filename is used (default: False).
        :param charset: The charset for files with a ``text/*`` mime-type.
            (default: UTF-8)
        :param etag: Provide a pre-computed ETag header. If set to ``False``,
            ETag handling is disabled. (default: auto-generate ETag header)
        :param headers: Additional headers dict to add to the response.

        While checking user input is always a good idea, this function provides
        additional protection against malicious ``filename`` parameters from
        breaking out of the ``root`` directory and leaking sensitive information
        to an attacker.

        Read-protected files or files outside of the ``root`` directory are
        answered with ``403 Access Denied``. Missing files result in a
        ``404 Not Found`` response. Conditional requests (``If-Modified-Since``,
        ``If-None-Match``) are answered with ``304 Not Modified`` whenever
        possible. ``HEAD`` and ``Range`` requests (used by download managers to
        check or continue partial downloads) are also handled automatically.
    """
    ...

def debug(mode=...): # -> None:
    """ Change the debug level.
    There is only one debug level supported at the moment."""
    ...

def http_date(value): # -> basestring:
    ...

def parse_date(ims): # -> int | None:
    """ Parse rfc1123, rfc850 and asctime timestamps and return UTC epoch. """
    ...

def parse_auth(header): # -> tuple[str | Any, str | Any] | None:
    """ Parse rfc2617 HTTP authentication header string (basic) and return (user,pass) tuple or None"""
    ...

def parse_range_header(header, maxlen=...): # -> Generator[tuple[int, int], Any, None]:
    """ Yield (start, end) ranges parsed from a HTTP Range header. Skip
        unsatisfiable ranges. The end index is non-inclusive."""
    ...

_hsplit = ...
def cookie_encode(data, key, digestmod=...): # -> bytes:
    """ Encode and sign a pickle-able object. Return a (byte) string """
    ...

def cookie_decode(data, key, digestmod=...): # -> Any | None:
    """ Verify and decode an encoded string. Return an object or None."""
    ...

def cookie_is_encoded(data): # -> bool:
    """ Return True if the argument looks like a encoded cookie."""
    ...

def html_escape(string):
    """ Escape HTML special characters ``&<>`` and quotes ``'"``. """
    ...

def html_quote(string):
    """ Escape and quote a string to be used as an HTTP attribute."""
    ...

def yieldroutes(func): # -> Generator[Any, Any, None]:
    """ Return a generator for routes that match the signature (name, args)
    of the func parameter. This may yield more than one route if the function
    takes optional keyword arguments. The output is best described by example::

        a()         -> '/a'
        b(x, y)     -> '/b/<x>/<y>'
        c(x, y=5)   -> '/c/<x>' and '/c/<x>/<y>'
        d(x=5, y=6) -> '/d' and '/d/<x>' and '/d/<x>/<y>'
    """
    ...

def path_shift(script_name, path_info, shift=...): # -> tuple[Any, Any] | tuple[LiteralString, LiteralString]:
    """ Shift path fragments from PATH_INFO to SCRIPT_NAME and vice versa.

        :return: The modified paths.
        :param script_name: The SCRIPT_NAME path.
        :param script_name: The PATH_INFO path.
        :param shift: The number of path fragments to shift. May be negative to
          change the shift direction. (default: 1)
    """
    ...

def auth_basic(check, realm=..., text=...): # -> Callable[..., _Wrapped[Callable[..., Any], Any, Callable[..., Any], HTTPError | Any]]:
    """ Callback decorator to require HTTP auth (basic).
        TODO: Add route(check_auth=...) parameter. """
    ...

def make_default_app_wrapper(name): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """ Return a callable that relays calls to the current default app. """
    ...

route = ...
get = ...
post = ...
put = ...
delete = ...
patch = ...
error = ...
mount = ...
hook = ...
install = ...
uninstall = ...
url = ...
class MultipartError(HTTPError):
    def __init__(self, msg) -> None:
        ...
    


class _MultipartParser:
    def __init__(self, stream, boundary, content_length=..., disk_limit=..., mem_limit=..., memfile_limit=..., buffer_size=..., charset=...) -> None:
        ...
    
    def parse(self): # -> Generator[_MultipartPart, Any, None]:
        """ Return a MultiPart iterator. Can only be called once. """
        ...
    


class _MultipartPart:
    def __init__(self, buffer_size=..., memfile_limit=..., charset=...) -> None:
        ...
    
    def feed(self, line, nl=...): # -> None:
        ...
    
    def write_header(self, line, nl): # -> None:
        ...
    
    def write_body(self, line, nl): # -> None:
        ...
    
    def finish_header(self): # -> None:
        ...
    
    def finish(self): # -> None:
        ...
    
    def is_buffered(self): # -> bool:
        """ Return true if the data is fully buffered in memory."""
        ...
    
    @property
    def value(self): # -> str:
        """ Data decoded with the specified charset """
        ...
    
    @property
    def raw(self): # -> bytes:
        """ Data without decoding """
        ...
    
    def close(self): # -> None:
        ...
    


class ServerAdapter:
    quiet = ...
    def __init__(self, host=..., port=..., **options) -> None:
        ...
    
    def run(self, handler): # -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class CGIServer(ServerAdapter):
    quiet = ...
    def run(self, handler): # -> None:
        ...
    


class FlupFCGIServer(ServerAdapter):
    def run(self, handler): # -> None:
        ...
    


class WSGIRefServer(ServerAdapter):
    def run(self, app): # -> None:
        class FixedHandler(WSGIRequestHandler):
            ...
        
        
    


class CherryPyServer(ServerAdapter):
    def run(self, handler): # -> None:
        ...
    


class CherootServer(ServerAdapter):
    def run(self, handler): # -> None:
        ...
    


class WaitressServer(ServerAdapter):
    def run(self, handler): # -> None:
        ...
    


class PasteServer(ServerAdapter):
    def run(self, handler): # -> None:
        ...
    


class MeinheldServer(ServerAdapter):
    def run(self, handler): # -> None:
        ...
    


class FapwsServer(ServerAdapter):
    """ Extremely fast webserver using libev. See https://github.com/william-os4y/fapws3 """
    def run(self, handler): # -> None:
        ...
    


class TornadoServer(ServerAdapter):
    """ The super hyped asynchronous server by facebook. Untested. """
    def run(self, handler): # -> None:
        ...
    


class AppEngineServer(ServerAdapter):
    """ Adapter for Google App Engine. """
    quiet = ...
    def run(self, handler): # -> None:
        ...
    


class TwistedServer(ServerAdapter):
    """ Untested. """
    def run(self, handler): # -> None:
        ...
    


class DieselServer(ServerAdapter):
    """ Untested. """
    def run(self, handler): # -> None:
        ...
    


class GeventServer(ServerAdapter):
    """ Untested. Options:

        * See gevent.wsgi.WSGIServer() documentation for more options.
    """
    def run(self, handler): # -> None:
        ...
    


class GunicornServer(ServerAdapter):
    """ Untested. See http://gunicorn.org/configure.html for options. """
    def run(self, handler):
        class GunicornApplication(BaseApplication):
            ...
        
        
    


class EventletServer(ServerAdapter):
    """ Untested. Options:

        * `backlog` adjust the eventlet backlog parameter which is the maximum
          number of queued connections. Should be at least 1; the maximum
          value is system-dependent.
        * `family`: (default is 2) socket family, optional. See socket
          documentation for available families.
    """
    def run(self, handler): # -> None:
        ...
    


class BjoernServer(ServerAdapter):
    """ Fast server written in C: https://github.com/jonashaag/bjoern """
    def run(self, handler): # -> None:
        ...
    


class AsyncioServerAdapter(ServerAdapter):
    """ Extend ServerAdapter for adding custom event loop """
    def get_event_loop(self): # -> None:
        ...
    


class AiohttpServer(AsyncioServerAdapter):
    """ Asynchronous HTTP client/server framework for asyncio
        https://pypi.python.org/pypi/aiohttp/
        https://pypi.org/project/aiohttp-wsgi/
    """
    def get_event_loop(self): # -> AbstractEventLoop:
        ...
    
    def run(self, handler): # -> None:
        ...
    


class AiohttpUVLoopServer(AiohttpServer):
    """uvloop
       https://github.com/MagicStack/uvloop
    """
    def get_event_loop(self):
        ...
    


class AutoServer(ServerAdapter):
    """ Untested. """
    adapters = ...
    def run(self, handler): # -> None:
        ...
    


server_names = ...
def load(target, **namespace): # -> ModuleType | Any:
    """ Import a module or fetch an object from a module.

        * ``package.module`` returns `module` as a module object.
        * ``pack.mod:name`` returns the module variable `name` from `pack.mod`.
        * ``pack.mod:func()`` calls `pack.mod.func()` and returns the result.

        The last form accepts not only function calls, but any type of
        expression. Keyword arguments passed to this function are available as
        local variables. Example: ``import_string('re:compile(x)', x='[a-z]')``
    """
    ...

def load_app(target): # -> ModuleType | Any | Bottle:
    """ Load a bottle application from a module and make sure that the import
        does not affect the current default application, but returns a separate
        application object. See :func:`load` for the target parameter. """
    ...

_debug = ...
def run(app=..., server=..., host=..., port=..., interval=..., reloader=..., quiet=..., plugins=..., debug=..., config=..., **kargs):
    """ Start a server instance. This method blocks until the server terminates.

        :param app: WSGI application or target string supported by
               :func:`load_app`. (default: :func:`default_app`)
        :param server: Server adapter to use. See :data:`server_names` keys
               for valid names or pass a :class:`ServerAdapter` subclass.
               (default: `wsgiref`)
        :param host: Server address to bind to. Pass ``0.0.0.0`` to listens on
               all interfaces including the external one. (default: 127.0.0.1)
        :param port: Server port to bind to. Values below 1024 require root
               privileges. (default: 8080)
        :param reloader: Start auto-reloading server? (default: False)
        :param interval: Auto-reloader interval in seconds (default: 1)
        :param quiet: Suppress output to stdout and stderr? (default: False)
        :param options: Options passed to the server adapter.
     """
    ...

class FileCheckerThread(threading.Thread):
    """ Interrupt main-thread as soon as a changed module file is detected,
        the lockfile gets deleted or gets too old. """
    def __init__(self, lockfile, interval) -> None:
        ...
    
    def run(self): # -> None:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, exc_type, *_): # -> bool:
        ...
    


class TemplateError(BottleException):
    ...


class BaseTemplate:
    """ Base class and minimal API for template adapters """
    extensions = ...
    settings = ...
    defaults = ...
    def __init__(self, source=..., name=..., lookup=..., encoding=..., **settings) -> None:
        """ Create a new template.
        If the source parameter (str or buffer) is missing, the name argument
        is used to guess a template filename. Subclasses can assume that
        self.source and/or self.filename are set. Both are strings.
        The lookup, encoding and settings parameters are stored as instance
        variables.
        The lookup parameter stores a list containing directory paths.
        The encoding parameter should be used to decode byte strings or files.
        The settings parameter contains a dict for engine-specific settings.
        """
        ...
    
    @classmethod
    def search(cls, name, lookup=...): # -> str | None:
        """ Search name in all directories specified in lookup.
        First without, then with common extensions. Return first hit. """
        ...
    
    @classmethod
    def global_config(cls, key, *args): # -> None:
        """ This reads or sets the global settings stored in class.settings. """
        ...
    
    def prepare(self, **options):
        """ Run preparations (parsing, caching, ...).
        It should be possible to call this again to refresh a template or to
        update settings.
        """
        ...
    
    def render(self, *args, **kwargs):
        """ Render the template with the specified local variables and return
        a single byte or unicode string. If it is a byte string, the encoding
        must match self.encoding. This method must be thread-safe!
        Local variables may be provided in dictionaries (args)
        or directly, as keywords (kwargs).
        """
        ...
    


class MakoTemplate(BaseTemplate):
    def prepare(self, **options): # -> None:
        ...
    
    def render(self, *args, **kwargs):
        ...
    


class CheetahTemplate(BaseTemplate):
    def prepare(self, **options): # -> None:
        ...
    
    def render(self, *args, **kwargs): # -> str:
        ...
    


class Jinja2Template(BaseTemplate):
    def prepare(self, filters=..., tests=..., globals=..., **kwargs): # -> None:
        ...
    
    def render(self, *args, **kwargs):
        ...
    
    def loader(self, name): # -> tuple[str, Any | str, Callable[[], Literal[False]]] | None:
        ...
    


class SimpleTemplate(BaseTemplate):
    def prepare(self, escape_func=..., noescape=..., syntax=..., **ka): # -> None:
        ...
    
    @cached_property
    def co(self): # -> CodeType:
        ...
    
    @cached_property
    def code(self): # -> LiteralString:
        ...
    
    def execute(self, _stdout, kwargs): # -> dict[Any, Any]:
        ...
    
    def render(self, *args, **kwargs): # -> LiteralString:
        """ Render the template using keyword arguments as local variables. """
        ...
    


class StplSyntaxError(TemplateError):
    ...


class StplParser:
    """ Parser for stpl templates. """
    _re_cache = ...
    _re_tok = ...
    _re_inl = ...
    _re_split = ...
    _re_inl = ...
    _re_tok = ...
    _re_inl = ...
    default_syntax = ...
    def __init__(self, source, syntax=..., encoding=...) -> None:
        ...
    
    def get_syntax(self):
        """ Tokens as a space separated string (default: <% %> % {{ }}) """
        ...
    
    def set_syntax(self, syntax): # -> None:
        ...
    
    syntax = ...
    def translate(self): # -> LiteralString:
        ...
    
    def read_code(self, pysource, multiline): # -> int:
        ...
    
    def flush_text(self): # -> None:
        ...
    
    @staticmethod
    def process_inline(chunk):
        ...
    
    def write_code(self, line, comment=...): # -> None:
        ...
    


def template(*args, **kwargs):
    """
    Get a rendered template as a string iterator.
    You can use a name, a filename or a template string as first parameter.
    Template rendering arguments can be passed as dictionaries
    or directly (as keyword arguments).
    """
    ...

mako_template = ...
cheetah_template = ...
jinja2_template = ...
def view(tpl_name, **defaults): # -> Callable[..., _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]]:
    """ Decorator: renders a template for a handler.
        The handler can control its behavior like that:

          - return a dict of template vars to fill out the template
          - return something other than a dict and the view decorator will not
            process the template, but return the handler result as is.
            This includes returning a HTTPResponse(dict) to get,
            for instance, JSON with autojson or other castfilters.
    """
    ...

mako_view = ...
cheetah_view = ...
jinja2_view = ...
TEMPLATE_PATH = ...
TEMPLATES = ...
DEBUG = ...
NORUN = ...
HTTP_CODES = ...
_HTTP_STATUS_LINES = ...
ERROR_PAGE_TEMPLATE = ...
request = ...
response = ...
local = ...
default_app = ...
ext = ...
def main(): # -> None:
    ...

if __name__ == '__main__':
    ...
