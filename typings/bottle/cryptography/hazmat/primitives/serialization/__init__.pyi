"""
This type stub file was generated by pyright.
"""

import binascii
import enum
import os
import re
import typing
import warnings
from base64 import encodebytes as _base64_encode
from dataclasses import dataclass
from cryptography import utils
from cryptography.exceptions import UnsupportedAlgorithm
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import dsa, ec, ed25519, padding, rsa, utils as asym_utils
from cryptography.hazmat.primitives.ciphers import AEADDecryptionContext, Cipher, algorithms, modes
from cryptography.hazmat.primitives.serialization import Encoding, KeySerializationEncryption, NoEncryption, PrivateFormat, PublicFormat, _KeySerializationEncryption
from bcrypt import kdf as _bcrypt_kdf

_bcrypt_supported = ...
_SSH_ED25519 = ...
_SSH_RSA = ...
_SSH_DSA = ...
_ECDSA_NISTP256 = ...
_ECDSA_NISTP384 = ...
_ECDSA_NISTP521 = ...
_CERT_SUFFIX = ...
_SK_SSH_ED25519 = ...
_SK_SSH_ECDSA_NISTP256 = ...
_SSH_RSA_SHA256 = ...
_SSH_RSA_SHA512 = ...
_SSH_PUBKEY_RC = ...
_SK_MAGIC = ...
_SK_START = ...
_SK_END = ...
_BCRYPT = ...
_NONE = ...
_DEFAULT_CIPHER = ...
_DEFAULT_ROUNDS = ...
_PEM_RC = ...
_PADDING = ...
@dataclass
class _SSHCipher:
    alg: type[algorithms.AES]
    key_len: int
    mode: type[modes.CTR] | type[modes.CBC] | type[modes.GCM]
    block_len: int
    iv_len: int
    tag_len: int | None
    is_aead: bool
    ...


_SSH_CIPHERS: dict[bytes, _SSHCipher] = ...
_ECDSA_KEY_TYPE = ...
class _FragList:
    """Build recursive structure without data copy."""
    flist: list[utils.Buffer]
    def __init__(self, init: list[utils.Buffer] | None = ...) -> None:
        ...
    
    def put_raw(self, val: utils.Buffer) -> None:
        """Add plain bytes"""
        ...
    
    def put_u32(self, val: int) -> None:
        """Big-endian uint32"""
        ...
    
    def put_u64(self, val: int) -> None:
        """Big-endian uint64"""
        ...
    
    def put_sshstr(self, val: bytes | _FragList) -> None:
        """Bytes prefixed with u32 length"""
        ...
    
    def put_mpint(self, val: int) -> None:
        """Big-endian bigint prefixed with u32 length"""
        ...
    
    def size(self) -> int:
        """Current number of bytes"""
        ...
    
    def render(self, dstbuf: memoryview, pos: int = ...) -> int:
        """Write into bytearray"""
        ...
    
    def tobytes(self) -> bytes:
        """Return as bytes"""
        ...
    


class _SSHFormatRSA:
    """Format for RSA keys.

    Public:
        mpint e, n
    Private:
        mpint n, e, d, iqmp, p, q
    """
    def get_public(self, data: memoryview) -> tuple[tuple[int, int], memoryview]:
        """RSA public fields"""
        ...
    
    def load_public(self, data: memoryview) -> tuple[rsa.RSAPublicKey, memoryview]:
        """Make RSA public key from data."""
        ...
    
    def load_private(self, data: memoryview, pubfields, unsafe_skip_rsa_key_validation: bool) -> tuple[rsa.RSAPrivateKey, memoryview]:
        """Make RSA private key from data."""
        ...
    
    def encode_public(self, public_key: rsa.RSAPublicKey, f_pub: _FragList) -> None:
        """Write RSA public key"""
        ...
    
    def encode_private(self, private_key: rsa.RSAPrivateKey, f_priv: _FragList) -> None:
        """Write RSA private key"""
        ...
    


class _SSHFormatDSA:
    """Format for DSA keys.

    Public:
        mpint p, q, g, y
    Private:
        mpint p, q, g, y, x
    """
    def get_public(self, data: memoryview) -> tuple[tuple, memoryview]:
        """DSA public fields"""
        ...
    
    def load_public(self, data: memoryview) -> tuple[dsa.DSAPublicKey, memoryview]:
        """Make DSA public key from data."""
        ...
    
    def load_private(self, data: memoryview, pubfields, unsafe_skip_rsa_key_validation: bool) -> tuple[dsa.DSAPrivateKey, memoryview]:
        """Make DSA private key from data."""
        ...
    
    def encode_public(self, public_key: dsa.DSAPublicKey, f_pub: _FragList) -> None:
        """Write DSA public key"""
        ...
    
    def encode_private(self, private_key: dsa.DSAPrivateKey, f_priv: _FragList) -> None:
        """Write DSA private key"""
        ...
    


class _SSHFormatECDSA:
    """Format for ECDSA keys.

    Public:
        str curve
        bytes point
    Private:
        str curve
        bytes point
        mpint secret
    """
    def __init__(self, ssh_curve_name: bytes, curve: ec.EllipticCurve) -> None:
        ...
    
    def get_public(self, data: memoryview) -> tuple[tuple[memoryview, memoryview], memoryview]:
        """ECDSA public fields"""
        ...
    
    def load_public(self, data: memoryview) -> tuple[ec.EllipticCurvePublicKey, memoryview]:
        """Make ECDSA public key from data."""
        ...
    
    def load_private(self, data: memoryview, pubfields, unsafe_skip_rsa_key_validation: bool) -> tuple[ec.EllipticCurvePrivateKey, memoryview]:
        """Make ECDSA private key from data."""
        ...
    
    def encode_public(self, public_key: ec.EllipticCurvePublicKey, f_pub: _FragList) -> None:
        """Write ECDSA public key"""
        ...
    
    def encode_private(self, private_key: ec.EllipticCurvePrivateKey, f_priv: _FragList) -> None:
        """Write ECDSA private key"""
        ...
    


class _SSHFormatEd25519:
    """Format for Ed25519 keys.

    Public:
        bytes point
    Private:
        bytes point
        bytes secret_and_point
    """
    def get_public(self, data: memoryview) -> tuple[tuple[memoryview], memoryview]:
        """Ed25519 public fields"""
        ...
    
    def load_public(self, data: memoryview) -> tuple[ed25519.Ed25519PublicKey, memoryview]:
        """Make Ed25519 public key from data."""
        ...
    
    def load_private(self, data: memoryview, pubfields, unsafe_skip_rsa_key_validation: bool) -> tuple[ed25519.Ed25519PrivateKey, memoryview]:
        """Make Ed25519 private key from data."""
        ...
    
    def encode_public(self, public_key: ed25519.Ed25519PublicKey, f_pub: _FragList) -> None:
        """Write Ed25519 public key"""
        ...
    
    def encode_private(self, private_key: ed25519.Ed25519PrivateKey, f_priv: _FragList) -> None:
        """Write Ed25519 private key"""
        ...
    


def load_application(data) -> tuple[memoryview, memoryview]:
    """
    U2F application strings
    """
    ...

class _SSHFormatSKEd25519:
    """
    The format of a sk-ssh-ed25519@openssh.com public key is:

        string		"sk-ssh-ed25519@openssh.com"
        string		public key
        string		application (user-specified, but typically "ssh:")
    """
    def load_public(self, data: memoryview) -> tuple[ed25519.Ed25519PublicKey, memoryview]:
        """Make Ed25519 public key from data."""
        ...
    
    def get_public(self, data: memoryview) -> typing.NoReturn:
        ...
    


class _SSHFormatSKECDSA:
    """
    The format of a sk-ecdsa-sha2-nistp256@openssh.com public key is:

        string		"sk-ecdsa-sha2-nistp256@openssh.com"
        string		curve name
        ec_point	Q
        string		application (user-specified, but typically "ssh:")
    """
    def load_public(self, data: memoryview) -> tuple[ec.EllipticCurvePublicKey, memoryview]:
        """Make ECDSA public key from data."""
        ...
    
    def get_public(self, data: memoryview) -> typing.NoReturn:
        ...
    


_KEY_FORMATS = ...
SSHPrivateKeyTypes = typing.Union[ec.EllipticCurvePrivateKey, rsa.RSAPrivateKey, dsa.DSAPrivateKey, ed25519.Ed25519PrivateKey,]
def load_ssh_private_key(data: utils.Buffer, password: bytes | None, backend: typing.Any = ..., *, unsafe_skip_rsa_key_validation: bool = ...) -> SSHPrivateKeyTypes:
    """Load private key from OpenSSH custom encoding."""
    ...

SSHPublicKeyTypes = typing.Union[ec.EllipticCurvePublicKey, rsa.RSAPublicKey, dsa.DSAPublicKey, ed25519.Ed25519PublicKey,]
SSHCertPublicKeyTypes = typing.Union[ec.EllipticCurvePublicKey, rsa.RSAPublicKey, ed25519.Ed25519PublicKey,]
class SSHCertificateType(enum.Enum):
    USER = ...
    HOST = ...


class SSHCertificate:
    def __init__(self, _nonce: memoryview, _public_key: SSHPublicKeyTypes, _serial: int, _cctype: int, _key_id: memoryview, _valid_principals: list[bytes], _valid_after: int, _valid_before: int, _critical_options: dict[bytes, bytes], _extensions: dict[bytes, bytes], _sig_type: memoryview, _sig_key: memoryview, _inner_sig_type: memoryview, _signature: memoryview, _tbs_cert_body: memoryview, _cert_key_type: bytes, _cert_body: memoryview) -> None:
        ...
    
    @property
    def nonce(self) -> bytes:
        ...
    
    def public_key(self) -> SSHCertPublicKeyTypes:
        ...
    
    @property
    def serial(self) -> int:
        ...
    
    @property
    def type(self) -> SSHCertificateType:
        ...
    
    @property
    def key_id(self) -> bytes:
        ...
    
    @property
    def valid_principals(self) -> list[bytes]:
        ...
    
    @property
    def valid_before(self) -> int:
        ...
    
    @property
    def valid_after(self) -> int:
        ...
    
    @property
    def critical_options(self) -> dict[bytes, bytes]:
        ...
    
    @property
    def extensions(self) -> dict[bytes, bytes]:
        ...
    
    def signature_key(self) -> SSHCertPublicKeyTypes:
        ...
    
    def public_bytes(self) -> bytes:
        ...
    
    def verify_cert_signature(self) -> None:
        ...
    


def load_ssh_public_identity(data: bytes) -> SSHCertificate | SSHPublicKeyTypes:
    ...

def ssh_key_fingerprint(key: SSHPublicKeyTypes, hash_algorithm: hashes.MD5 | hashes.SHA256) -> bytes:
    ...

def load_ssh_public_key(data: utils.Buffer, backend: typing.Any = ...) -> SSHPublicKeyTypes:
    ...

def serialize_ssh_public_key(public_key: SSHPublicKeyTypes) -> bytes:
    """One-line public key format for OpenSSH"""
    ...

SSHCertPrivateKeyTypes = typing.Union[ec.EllipticCurvePrivateKey, rsa.RSAPrivateKey, ed25519.Ed25519PrivateKey,]
_SSHKEY_CERT_MAX_PRINCIPALS = ...
class SSHCertificateBuilder:
    def __init__(self, _public_key: SSHCertPublicKeyTypes | None = ..., _serial: int | None = ..., _type: SSHCertificateType | None = ..., _key_id: bytes | None = ..., _valid_principals: list[bytes] = ..., _valid_for_all_principals: bool = ..., _valid_before: int | None = ..., _valid_after: int | None = ..., _critical_options: list[tuple[bytes, bytes]] = ..., _extensions: list[tuple[bytes, bytes]] = ...) -> None:
        ...
    
    def public_key(self, public_key: SSHCertPublicKeyTypes) -> SSHCertificateBuilder:
        ...
    
    def serial(self, serial: int) -> SSHCertificateBuilder:
        ...
    
    def type(self, type: SSHCertificateType) -> SSHCertificateBuilder:
        ...
    
    def key_id(self, key_id: bytes) -> SSHCertificateBuilder:
        ...
    
    def valid_principals(self, valid_principals: list[bytes]) -> SSHCertificateBuilder:
        ...
    
    def valid_for_all_principals(self): # -> SSHCertificateBuilder:
        ...
    
    def valid_before(self, valid_before: int | float) -> SSHCertificateBuilder:
        ...
    
    def valid_after(self, valid_after: int | float) -> SSHCertificateBuilder:
        ...
    
    def add_critical_option(self, name: bytes, value: bytes) -> SSHCertificateBuilder:
        ...
    
    def add_extension(self, name: bytes, value: bytes) -> SSHCertificateBuilder:
        ...
    
    def sign(self, private_key: SSHCertPrivateKeyTypes) -> SSHCertificate:
        ...
    


