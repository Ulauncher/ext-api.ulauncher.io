"""
This type stub file was generated by pyright.
"""

import json as _json
import logging
import typing
from contextlib import contextmanager
from dataclasses import dataclass
from http.client import HTTPException as HTTPException
from io import BytesIO, IOBase
from ...exceptions import InvalidHeader, TimeoutError
from ...response import BaseHTTPResponse
from ...util.retry import Retry
from .request import EmscriptenRequest
from ..._base_connection import BaseHTTPConnection, BaseHTTPSConnection

if typing.TYPE_CHECKING:
    ...
log = ...
@dataclass
class EmscriptenResponse:
    status_code: int
    headers: dict[str, str]
    body: IOBase | bytes
    request: EmscriptenRequest
    ...


class EmscriptenHttpResponseWrapper(BaseHTTPResponse):
    def __init__(self, internal_response: EmscriptenResponse, url: str | None = ..., connection: BaseHTTPConnection | BaseHTTPSConnection | None = ...) -> None:
        ...
    
    @property
    def url(self) -> str | None:
        ...
    
    @url.setter
    def url(self, url: str | None) -> None:
        ...
    
    @property
    def connection(self) -> BaseHTTPConnection | BaseHTTPSConnection | None:
        ...
    
    @property
    def retries(self) -> Retry | None:
        ...
    
    @retries.setter
    def retries(self, retries: Retry | None) -> None:
        ...
    
    def stream(self, amt: int | None = ..., decode_content: bool | None = ...) -> typing.Generator[bytes]:
        """
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.

        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        ...
    
    def read(self, amt: int | None = ..., decode_content: bool | None = ..., cache_content: bool = ...) -> bytes:
        ...
    
    def read_chunked(self, amt: int | None = ..., decode_content: bool | None = ...) -> typing.Generator[bytes]:
        ...
    
    def release_conn(self) -> None:
        ...
    
    def drain_conn(self) -> None:
        ...
    
    @property
    def data(self) -> bytes:
        ...
    
    def json(self) -> typing.Any:
        """
        Deserializes the body of the HTTP response as a Python object.

        The body of the HTTP response must be encoded using UTF-8, as per
        `RFC 8529 Section 8.1 <https://www.rfc-editor.org/rfc/rfc8259#section-8.1>`_.

        To use a custom JSON decoder pass the result of :attr:`HTTPResponse.data` to
        your custom decoder instead.

        If the body of the HTTP response is not decodable to UTF-8, a
        `UnicodeDecodeError` will be raised. If the body of the HTTP response is not a
        valid JSON document, a `json.JSONDecodeError` will be raised.

        Read more :ref:`here <json_content>`.

        :returns: The body of the HTTP response as a Python object.
        """
        ...
    
    def close(self) -> None:
        ...
    


