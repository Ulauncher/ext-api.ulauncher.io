"""
This type stub file was generated by pyright.
"""

import logging
import re
import threading
import types
import typing
import h2.config
import h2.connection
import h2.events
from .._base_connection import _TYPE_BODY
from .._collections import HTTPHeaderDict
from ..connection import HTTPSConnection, _get_default_user_agent
from ..exceptions import ConnectionError
from ..response import BaseHTTPResponse

orig_HTTPSConnection = HTTPSConnection
T = typing.TypeVar("T")
log = ...
RE_IS_LEGAL_HEADER_NAME = ...
RE_IS_ILLEGAL_HEADER_VALUE = ...
class _LockedObject(typing.Generic[T]):
    """
    A wrapper class that hides a specific object behind a lock.
    The goal here is to provide a simple way to protect access to an object
    that cannot safely be simultaneously accessed from multiple threads. The
    intended use of this class is simple: take hold of it with a context
    manager, which returns the protected object.
    """
    __slots__ = ...
    def __init__(self, obj: T) -> None:
        ...
    
    def __enter__(self) -> T:
        ...
    
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None:
        ...
    


class HTTP2Connection(HTTPSConnection):
    def __init__(self, host: str, port: int | None = ..., **kwargs: typing.Any) -> None:
        ...
    
    def connect(self) -> None:
        ...
    
    def putrequest(self, method: str, url: str, **kwargs: typing.Any) -> None:
        """putrequest
        This deviates from the HTTPConnection method signature since we never need to override
        sending accept-encoding headers or the host header.
        """
        ...
    
    def putheader(self, header: str | bytes, *values: str | bytes) -> None:
        ...
    
    def endheaders(self, message_body: typing.Any = ...) -> None:
        ...
    
    def send(self, data: typing.Any) -> None:
        """Send data to the server.
        `data` can be: `str`, `bytes`, an iterable, or file-like objects
        that support a .read() method.
        """
        ...
    
    def set_tunnel(self, host: str, port: int | None = ..., headers: typing.Mapping[str, str] | None = ..., scheme: str = ...) -> None:
        ...
    
    def getresponse(self) -> HTTP2Response:
        ...
    
    def request(self, method: str, url: str, body: _TYPE_BODY | None = ..., headers: typing.Mapping[str, str] | None = ..., *, preload_content: bool = ..., decode_content: bool = ..., enforce_content_length: bool = ..., **kwargs: typing.Any) -> None:
        """Send an HTTP/2 request"""
        ...
    
    def close(self) -> None:
        ...
    


class HTTP2Response(BaseHTTPResponse):
    def __init__(self, status: int, headers: HTTPHeaderDict, request_url: str, data: bytes, decode_content: bool = ...) -> None:
        ...
    
    @property
    def data(self) -> bytes:
        ...
    
    def get_redirect_location(self) -> None:
        ...
    
    def close(self) -> None:
        ...
    


